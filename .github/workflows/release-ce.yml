name: Build, Stage, and Deploy Release

on:
  pull_request:
    types: [ closed ]
    branches: [ release ]
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (no actual deployments)'
        required: false
        type: boolean
        default: true

jobs:
  calculate-version:
    name: Calculate Next Version
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || (github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'release')
    outputs:
      version: ${{ steps.version.outputs.version }}
      previous_version: ${{ steps.version.outputs.previous_version }}
      dry_run: ${{ steps.dry_run.outputs.enabled }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set dry run mode
        id: dry_run
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            DRY_RUN="${{ inputs.dry_run }}"
          else
            # PR merges to release branch are always production
            DRY_RUN="false"
          fi
          echo "enabled=$DRY_RUN" >> $GITHUB_OUTPUT
          echo "Dry run mode: $DRY_RUN"

      - name: Calculate version
        id: version
        run: |
          NEXT_VERSION=$(bash scripts/version-bump.sh)
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          PREVIOUS_VERSION="${LATEST_TAG#v}"
          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT
          echo "Next version: $NEXT_VERSION"
          echo "Previous version: $PREVIOUS_VERSION"

  build-docker-ce:
    name: Build Docker Images (CE)
    strategy:
      matrix:
        include:
          - runner: ubuntu-latest
            platform: linux/amd64
            arch: amd64
          - runner: ubuntu-24.04-arm64  # Native ARM64 build
            platform: linux/arm64
            arch: arm64
    runs-on: ${{ matrix.runner }}
    needs: calculate-version
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for ${{ matrix.platform }}
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./core/Dockerfile
          platforms: ${{ matrix.platform }}
          push: false
          tags: clidey/whodb:${{ needs.calculate-version.outputs.version }}-${{ matrix.arch }}
          outputs: type=oci,dest=/tmp/whodb-docker-${{ matrix.arch }}.tar

      - name: Upload Docker artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ matrix.arch }}
          path: /tmp/whodb-docker-${{ matrix.arch }}.tar
          retention-days: 1

  build-desktop-ce:
    name: Build Desktop Executables (CE)
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
            arch: amd64
            make-target: build-prod-linux-amd64
          - os: ubuntu-24.04-arm64  # Use native ARM64 runner for Linux ARM64
            platform: linux
            arch: arm64
            make-target: build-prod-linux-arm64
          - os: macos-latest
            platform: darwin
            make-target-universal: build-prod-mac
          - os: windows-latest
            platform: windows
            arch: amd64
            make-target: build-prod-windows-amd64
          - os: windows-11-arm  # Use native ARM64 runner for Windows ARM64
            platform: windows
            arch: arm64
            make-target: build-prod-windows-arm64
    runs-on: ${{ matrix.os }}
    needs: calculate-version
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'desktop-ce/go.mod'

      - name: Setup Node.js and pnpm
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'

      - uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: pnpm i

      - name: Install Wails CLI
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest

      - name: Install Linux dependencies
        if: matrix.platform == 'linux'
        run: sudo apt-get update && sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev upx-ucl

      - name: Build Linux
        if: matrix.platform == 'linux'
        working-directory: ./desktop-ce
        run: make ${{ matrix.make-target }} VERSION=${{ needs.calculate-version.outputs.version }}

      - name: Build macOS universal
        if: matrix.platform == 'darwin'
        working-directory: ./desktop-ce
        run: make ${{ matrix.make-target-universal }} VERSION=${{ needs.calculate-version.outputs.version }}

      - name: Build Windows
        if: matrix.platform == 'windows'
        working-directory: ./desktop-ce
        shell: pwsh
        run: make ${{ matrix.make-target }} VERSION=${{ needs.calculate-version.outputs.version }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: desktop-${{ matrix.platform }}-${{ matrix.arch || 'all' }}
          path: |
            desktop-ce/build/
          retention-days: 1

  package-linux-appimage:
    name: Package Linux AppImages
    runs-on: ubuntu-latest
    needs: [ calculate-version, build-desktop-ce ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Linux amd64 builds
        uses: actions/download-artifact@v4
        with:
          name: desktop-linux-amd64
          path: desktop-ce/

      - name: Download Linux arm64 builds
        uses: actions/download-artifact@v4
        with:
          name: desktop-linux-arm64
          path: desktop-ce/

      - name: Build AppImage amd64
        run: bash scripts/build-appimage.sh amd64 ${{ needs.calculate-version.outputs.version }}

      - name: Build AppImage arm64
        run: bash scripts/build-appimage.sh arm64 ${{ needs.calculate-version.outputs.version }}

      - name: Upload AppImage artifacts
        uses: actions/upload-artifact@v4
        with:
          name: appimages
          path: WhoDB-*.AppImage
          retention-days: 1

  package-mac-dmg:
    name: Package macOS DMG
    runs-on: macos-latest
    needs: [ calculate-version, build-desktop-ce ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download macOS build
        uses: actions/download-artifact@v4
        with:
          name: desktop-darwin-all
          path: desktop-ce/

      - name: Create DMG
        working-directory: ./desktop-ce
        run: |
          rm -rf build/dmgroot && mkdir -p build/dmgroot
          cp -R "build/darwin/universal/WhoDB.app" build/dmgroot/
          ln -sf /Applications build/dmgroot/Applications
          hdiutil create -volname "WhoDB" -srcfolder build/dmgroot -ov -format UDZO \
            "WhoDB-${{ needs.calculate-version.outputs.version }}.dmg"

      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        with:
          name: macos-dmg
          path: desktop-ce/WhoDB-*.dmg
          retention-days: 1

  package-windows-msix:
    name: Package Windows MSIX
    runs-on: windows-latest
    needs: [ calculate-version, build-desktop-ce ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Windows amd64 builds
        uses: actions/download-artifact@v4
        with:
          name: desktop-windows-amd64
          path: desktop-ce/

      - name: Download Windows arm64 builds
        uses: actions/download-artifact@v4
        with:
          name: desktop-windows-arm64
          path: desktop-ce/

      - name: Skip MSIX packaging in dry run
        if: needs.calculate-version.outputs.dry_run == 'true'
        shell: pwsh
        run: |
          echo "üèÉ DRY RUN MODE - Skipping MSIX packaging (requires certificate)"
          echo "Creating dummy MSIX files for validation..."
          New-Item -ItemType File -Path "WhoDB-${{ needs.calculate-version.outputs.version }}-amd64.msix" -Force
          New-Item -ItemType File -Path "WhoDB-${{ needs.calculate-version.outputs.version }}-arm64.msix" -Force

      - name: Decode certificate
        if: needs.calculate-version.outputs.dry_run == 'false'
        shell: pwsh
        run: |
          $bytes = [Convert]::FromBase64String("${{ secrets.WINDOWS_PFX_BASE64 }}")
          [IO.File]::WriteAllBytes("cert.pfx", $bytes)

      - name: Build MSIX amd64
        if: needs.calculate-version.outputs.dry_run == 'false'
        shell: pwsh
        env:
          WINDOWS_PFX_PASSWORD: ${{ secrets.WINDOWS_PFX_PASSWORD }}
        run: |
          .\scripts\build-msix.ps1 -Architecture amd64 -Version ${{ needs.calculate-version.outputs.version }} -PublisherCN "${{ secrets.WINDOWS_PUBLISHER_CN }}" -CertPath cert.pfx

      - name: Build MSIX arm64
        if: needs.calculate-version.outputs.dry_run == 'false'
        shell: pwsh
        env:
          WINDOWS_PFX_PASSWORD: ${{ secrets.WINDOWS_PFX_PASSWORD }}
        run: |
          .\scripts\build-msix.ps1 -Architecture arm64 -Version ${{ needs.calculate-version.outputs.version }} -PublisherCN "${{ secrets.WINDOWS_PUBLISHER_CN }}" -CertPath cert.pfx

      - name: Upload MSIX artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-msix
          path: WhoDB-*.msix
          retention-days: 1

  build-snap:
    name: Build Snap Package
    runs-on: ubuntu-latest
    needs: [ calculate-version, build-desktop-ce ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Linux amd64 builds
        uses: actions/download-artifact@v4
        with:
          name: desktop-linux-amd64
          path: desktop-ce/

      - name: Download Linux arm64 builds
        uses: actions/download-artifact@v4
        with:
          name: desktop-linux-arm64
          path: desktop-ce/

      - name: Build snap
        uses: snapcore/action-build@v1
        id: build
        with:
          path: desktop-ce

      - name: Upload snap artifact
        uses: actions/upload-artifact@v4
        with:
          name: snap-package
          path: ${{ steps.build.outputs.snap }}
          retention-days: 1

  build-flatpak:
    name: Build Flatpak Package
    runs-on: ubuntu-latest
    needs: [ calculate-version, build-desktop-ce ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Linux amd64 builds
        uses: actions/download-artifact@v4
        with:
          name: desktop-linux-amd64
          path: desktop-ce/

      - name: Download Linux arm64 builds
        uses: actions/download-artifact@v4
        with:
          name: desktop-linux-arm64
          path: desktop-ce/

      - name: Install flatpak
        run: |
          sudo apt-get update
          sudo apt-get install -y flatpak flatpak-builder

      - name: Build flatpak
        uses: flatpak/flatpak-github-actions/flatpak-builder@v6
        with:
          bundle: WhoDB-${{ needs.calculate-version.outputs.version }}.flatpak
          manifest-path: flatpak/com.clidey.whodb.ce.yml

      - name: Upload flatpak artifact
        uses: actions/upload-artifact@v4
        with:
          name: flatpak-package
          path: WhoDB-*.flatpak
          retention-days: 1

  sign-with-sigstore:
    name: Sign Artifacts with Sigstore
    runs-on: ubuntu-latest
    needs: [ calculate-version, package-linux-appimage, package-mac-dmg, package-windows-msix, build-snap, build-flatpak, build-desktop-ce ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Sign Linux AppImages
        run: |
          for file in artifacts/appimages/*.AppImage; do
            cosign sign-blob --yes "$file" --output-signature="${file}.sig" --output-certificate="${file}.pem"
          done

      - name: Sign macOS DMG
        run: |
          for file in artifacts/macos-dmg/*.dmg; do
            cosign sign-blob --yes "$file" --output-signature="${file}.sig" --output-certificate="${file}.pem"
          done

      - name: Sign Windows NSIS installers
        run: |
          for file in artifacts/desktop-windows-*/build/windows/*/*.exe; do
            [ -f "$file" ] && cosign sign-blob --yes "$file" --output-signature="${file}.sig" --output-certificate="${file}.pem"
          done

      - name: Sign Windows MSIX packages
        run: |
          for file in artifacts/windows-msix/*.msix; do
            cosign sign-blob --yes "$file" --output-signature="${file}.sig" --output-certificate="${file}.pem"
          done

      - name: Sign Linux executables
        run: |
          for file in artifacts/desktop-linux-*/build/linux/*/whodb; do
            [ -f "$file" ] && cosign sign-blob --yes "$file" --output-signature="${file}.sig" --output-certificate="${file}.pem"
          done

      - name: Upload signed artifacts
        uses: actions/upload-artifact@v4
        with:
          name: signed-artifacts
          path: artifacts/
          retention-days: 1

  validate-all-builds:
    name: Validate All Builds
    runs-on: ubuntu-latest
    needs: [ sign-with-sigstore, build-docker-ce ]
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Validate artifacts
        run: |
          echo "Checking for required artifacts..."
          [ -f "artifacts/docker-image-amd64/whodb-docker-amd64.tar" ] || (echo "Docker amd64 image missing" && exit 1)
          [ -f "artifacts/docker-image-arm64/whodb-docker-arm64.tar" ] || (echo "Docker arm64 image missing" && exit 1)
          [ -f "artifacts/appimages/"*.AppImage ] || (echo "AppImages missing" && exit 1)
          [ -f "artifacts/macos-dmg/"*.dmg ] || (echo "macOS DMG missing" && exit 1)
          [ -f "artifacts/windows-msix/"*.msix ] || (echo "Windows MSIX missing" && exit 1)
          [ -f "artifacts/snap-package/"*.snap ] || (echo "Snap package missing" && exit 1)
          [ -f "artifacts/flatpak-package/"*.flatpak ] || (echo "Flatpak package missing" && exit 1)
          echo "‚úì All artifacts present"

      - name: Initialize deployment manifest
        run: |
          bash scripts/track-deployment.sh docker pending ${{ needs.calculate-version.outputs.version }}

      - name: Upload deployment manifest
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest
          path: deployment_manifest.json
          retention-days: 1

  deploy-docker:
    name: Deploy Docker Images
    runs-on: ubuntu-latest
    needs: [ calculate-version, validate-all-builds ]
    steps:
      - name: Checkout for scripts
        uses: actions/checkout@v4

      - name: Download Docker amd64 artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-amd64
          path: /tmp

      - name: Download Docker arm64 artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-arm64
          path: /tmp

      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest
          path: .

      - name: Load Docker images
        run: |
          docker load --input /tmp/whodb-docker-amd64.tar
          docker load --input /tmp/whodb-docker-arm64.tar

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Install Cosign
        if: needs.calculate-version.outputs.dry_run == 'false'
        uses: sigstore/cosign-installer@v3

      - name: Set up Docker Buildx for manifest
        uses: docker/setup-buildx-action@v3

      - name: Push Docker images and create manifest
        if: needs.calculate-version.outputs.dry_run == 'false'
        run: |
          # Push individual platform images
          docker push clidey/whodb:${{ needs.calculate-version.outputs.version }}-amd64 || exit 1
          docker push clidey/whodb:${{ needs.calculate-version.outputs.version }}-arm64 || exit 1

          # Create and push multi-platform manifests
          docker buildx imagetools create -t clidey/whodb:${{ needs.calculate-version.outputs.version }} \
            clidey/whodb:${{ needs.calculate-version.outputs.version }}-amd64 \
            clidey/whodb:${{ needs.calculate-version.outputs.version }}-arm64

          docker buildx imagetools create -t clidey/whodb:latest \
            clidey/whodb:${{ needs.calculate-version.outputs.version }}-amd64 \
            clidey/whodb:${{ needs.calculate-version.outputs.version }}-arm64

          bash scripts/track-deployment.sh docker deployed ${{ needs.calculate-version.outputs.version }}

      - name: Sign Docker images
        if: needs.calculate-version.outputs.dry_run == 'false'
        run: |
          cosign sign --yes clidey/whodb:${{ needs.calculate-version.outputs.version }}
          cosign sign --yes clidey/whodb:latest

      - name: Dry run summary
        if: needs.calculate-version.outputs.dry_run == 'true'
        run: |
          echo "üèÉ DRY RUN MODE"
          echo "‚úÖ Successfully logged in to Docker Hub"
          echo "üì¶ Would have pushed:"
          echo "  - clidey/whodb:${{ needs.calculate-version.outputs.version }}"
          echo "  - clidey/whodb:latest"
          echo "üîè Would have signed both images with Sigstore"

      - name: Upload updated manifest
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest-docker
          path: deployment_manifest.json
          retention-days: 1

  deploy-snap:
    name: Deploy to Snap Store
    runs-on: ubuntu-latest
    needs: [ calculate-version, create-github-release ]
    steps:
      - name: Checkout for scripts
        uses: actions/checkout@v4

      - name: Download snap artifact
        uses: actions/download-artifact@v4
        with:
          name: snap-package

      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest-github
          path: .

      - name: Capture current Snap Store state
        if: needs.calculate-version.outputs.dry_run == 'false'
        env:
          SNAPCRAFT_STORE_CREDENTIALS: ${{ secrets.SNAPCRAFT_STORE_CREDENTIALS }}
        run: |
          bash scripts/capture-store-state.sh whodb

      - name: Publish to Snap Store
        if: needs.calculate-version.outputs.dry_run == 'false'
        uses: snapcore/action-publish@v1
        env:
          SNAPCRAFT_STORE_CREDENTIALS: ${{ secrets.SNAPCRAFT_STORE_CREDENTIALS }}
        with:
          snap: '*.snap'
          release: stable

      - name: Track Snap deployment
        if: needs.calculate-version.outputs.dry_run == 'false'
        run: |
          bash scripts/track-deployment.sh snap deployed ${{ needs.calculate-version.outputs.version }}

      - name: Dry run summary
        if: needs.calculate-version.outputs.dry_run == 'true'
        run: |
          echo "üèÉ DRY RUN MODE - Would have published:"
          echo "  - Snap package to stable channel"
          ls -lh *.snap

      - name: Upload updated manifest
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest-snap
          path: deployment_manifest.json
          retention-days: 1

      - name: Upload store state
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: store-state
          path: store_state.json
          retention-days: 1

  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [ calculate-version, deploy-docker ]
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest-docker
          path: .

      - name: Download all signed artifacts
        uses: actions/download-artifact@v4
        with:
          name: signed-artifacts
          path: release-assets/

      - name: Prepare release assets
        run: |
          mkdir -p final-assets

          # Copy AppImages
          cp release-assets/appimages/*.AppImage final-assets/ || true
          cp release-assets/appimages/*.sig final-assets/ || true

          # Copy macOS DMG
          cp release-assets/macos-dmg/*.dmg final-assets/ || true
          cp release-assets/macos-dmg/*.sig final-assets/ || true

          # Copy Windows installers and MSIX
          cp release-assets/desktop-windows-*/build/windows/*/*.exe final-assets/ || true
          cp release-assets/windows-msix/*.msix final-assets/ || true
          cp release-assets/windows-msix/*.sig final-assets/ || true

          # Copy Linux executables
          cp release-assets/desktop-linux-amd64/build/linux/amd64/whodb final-assets/whodb-linux-amd64 || true
          cp release-assets/desktop-linux-arm64/build/linux/arm64/whodb final-assets/whodb-linux-arm64 || true

      - name: Generate checksums
        working-directory: final-assets
        run: |
          sha256sum * > SHA256SUMS.txt

      - name: Create Release
        id: create_release
        if: needs.calculate-version.outputs.dry_run == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.calculate-version.outputs.version }}
          name: Release v${{ needs.calculate-version.outputs.version }}
          body: |
            # WhoDB v${{ needs.calculate-version.outputs.version }}

            ## Docker Images
            - `docker pull clidey/whodb:${{ needs.calculate-version.outputs.version }}`
            - `docker pull clidey/whodb:latest`

            ## Installation

            **Snap:**
            ```bash
            sudo snap install whodb
            ```

            **Flatpak:**
            Manual installation - See Flathub for updates

            ## Release Notes
            [TODO: Add release notes here]

            ## Verification
            All binaries are signed with Sigstore. Verify signatures using cosign:
            ```bash
            cosign verify-blob --signature <file>.sig --certificate <file>.pem <file>
            ```
          files: final-assets/*
          draft: false
          prerelease: false

      - name: Track GitHub release
        if: needs.calculate-version.outputs.dry_run == 'false'
        run: |
          bash scripts/track-deployment.sh github_release deployed ${{ needs.calculate-version.outputs.version }} "${{ steps.create_release.outputs.id }}"

      - name: Dry run summary
        if: needs.calculate-version.outputs.dry_run == 'true'
        run: |
          echo "üèÉ DRY RUN MODE - Would have created GitHub release:"
          echo "  - Tag: v${{ needs.calculate-version.outputs.version }}"
          echo "  - Files:"
          ls -lh final-assets/

      - name: Upload updated manifest
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest-github
          path: deployment_manifest.json
          retention-days: 1

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    if: failure() && needs.calculate-version.outputs.dry_run == 'false'
    needs: [ calculate-version, deploy-docker, create-github-release, deploy-snap ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest-snap
          path: .
        continue-on-error: true

      - name: Download store state
        uses: actions/download-artifact@v4
        with:
          name: store-state
          path: .
        continue-on-error: true

      - name: Enhanced comprehensive rollback
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          SNAPCRAFT_STORE_CREDENTIALS: ${{ secrets.SNAPCRAFT_STORE_CREDENTIALS }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          WINDOWS_TENANT_ID: ${{ secrets.WINDOWS_TENANT_ID }}
          WINDOWS_CLIENT_ID: ${{ secrets.WINDOWS_CLIENT_ID }}
          WINDOWS_CLIENT_SECRET: ${{ secrets.WINDOWS_CLIENT_SECRET }}
          WINDOWS_APP_ID: ${{ secrets.WINDOWS_APP_ID }}
        run: |
          bash scripts/rollback-all.sh \
            ${{ needs.calculate-version.outputs.version }} \
            ${{ needs.calculate-version.outputs.previous_version }} \
            deployment_manifest.json \
            store_state.json

      - name: Notify rollback
        run: |
          echo "::error::Deployment failed and has been rolled back"
          echo "Failed version: ${{ needs.calculate-version.outputs.version }}"
          echo "Reverted to: ${{ needs.calculate-version.outputs.previous_version }}"
          echo ""
          echo "Rollback actions taken:"
          echo "  - Docker: Reverted latest tag to ${{ needs.calculate-version.outputs.previous_version }}"
          echo "  - Docker: Deleted tag ${{ needs.calculate-version.outputs.version }}"
          echo "  - Snap: Manual verification required in Snapcraft dashboard"
          echo "  - GitHub: Release and tag deleted if they existed"
          exit 1

  verify-deployment:
    name: Verify Deployment Success
    runs-on: ubuntu-latest
    needs: [ calculate-version, deploy-snap ]
    if: needs.calculate-version.outputs.dry_run == 'false'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download final deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest-snap
          path: .

      - name: Verify all deployments successful
        run: |
          echo "Verifying deployment status..."

          DOCKER_STATUS=$(jq -r '.docker.status' deployment_manifest.json)
          SNAP_STATUS=$(jq -r '.snap.status' deployment_manifest.json)
          GITHUB_STATUS=$(jq -r '.github_release.status' deployment_manifest.json)

          echo "Docker deployment: $DOCKER_STATUS"
          echo "Snap deployment: $SNAP_STATUS"
          echo "GitHub release: $GITHUB_STATUS"

          if [ "$DOCKER_STATUS" != "deployed" ] || [ "$SNAP_STATUS" != "deployed" ] || [ "$GITHUB_STATUS" != "deployed" ]; then
            echo "::error::Not all deployments completed successfully"
            exit 1
          fi

          echo "‚úì All deployments verified successful"

      - name: Test Docker image availability
        run: |
          echo "Testing Docker image pull..."
          docker pull clidey/whodb:${{ needs.calculate-version.outputs.version }} || exit 1
          echo "‚úì Docker image is accessible"

      - name: Verify GitHub release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Verifying GitHub release..."
          RELEASE_URL="https://api.github.com/repos/${{ github.repository }}/releases/tags/v${{ needs.calculate-version.outputs.version }}"
          RELEASE_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $GITHUB_TOKEN" "$RELEASE_URL")

          if [ "$RELEASE_STATUS" != "200" ]; then
            echo "::error::GitHub release not found (HTTP $RELEASE_STATUS)"
            exit 1
          fi

          echo "‚úì GitHub release verified"
